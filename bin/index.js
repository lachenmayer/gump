// Generated by CoffeeScript 1.7.1
(function() {
  var browserSync, cache, filter, gulp, gulpSrcForArgs, livereload, notify, once, parseArguments, path, pipe, reportMissingSource, reportWrongUseOfWatch, serving, shouldServe, subdir,
    __slice = [].slice;

  path = require('path');

  gulp = require('gulp');

  cache = require('gulp-cached');

  notify = require('gulp-notify');

  filter = require('gulp-filter');

  once = require('once');

  subdir = require('subdir');

  browserSync = require('browser-sync');

  reportMissingSource = function(name) {
    var cyan, red, _ref;
    _ref = gutil.colors, red = _ref.red, cyan = _ref.cyan;
    gutil.log(red('[Gump Fatal Error]', red('Succint style used for a'), cyan('task'), red('called'), name, red('but missing a source!')));
    throw new gutil.PluginError('Gump', 'missing source');
  };

  reportWrongUseOfWatch = function(name) {
    var red;
    red = gutil.colors.red;
    gutil.log(red('[Gump Fatal Error]', cyan('watch'), name, red('requires succint style, but callback given')));
    throw new gutil.PluginError('Gump', 'wrong style for watch');
  };

  gulpSrcForArgs = function(args) {
    var opts, potentialOpts, srcs, _ref;
    srcs = [];
    while (args.length > 0 && typeof args[0] === 'string') {
      srcs.push(args[0]);
      args = args.slice(1);
    }
    if (args.length > 0) {
      potentialOpts = args[0];
      if (potentialOpts && ((_ref = typeof potentialOpts) !== 'function' && _ref !== 'string')) {
        opts = potentialOpts;
        args = args.slice(1);
      }
    }
    return [
      (function() {
        return gulp.src(srcs, opts);
      }), srcs, args
    ];
  };

  parseArguments = function(_arg) {
    var args, callback, deps, dest, lastArg, name, pipes, potentialDeps, src, srcs, _i, _ref;
    name = _arg[0], args = 3 <= _arg.length ? __slice.call(_arg, 1, _i = _arg.length - 1) : (_i = 1, []), lastArg = _arg[_i++];
    if (args.length > 0) {
      potentialDeps = args[0];
      if (Array.isArray(potentialDeps)) {
        deps = potentialDeps;
        args = args.slice(1);
      }
    }
    if (!lastArg || typeof lastArg === 'string') {
      dest = lastArg;
      if (args.length < 1) {
        reportMissingSource(name);
      }
      src = args[0];
      if (typeof src === 'function') {
        pipes = args.slice(1);
      } else {
        _ref = gulpSrcForArgs(args), src = _ref[0], srcs = _ref[1], pipes = _ref[2];
      }
    } else {
      callback = lastArg;
    }
    return {
      name: name,
      deps: deps,
      callback: callback,
      src: src,
      srcs: srcs,
      pipes: pipes,
      dest: dest
    };
  };

  pipe = function(stream, pipes, dest) {
    var step, _i, _len;
    for (_i = 0, _len = pipes.length; _i < _len; _i++) {
      step = pipes[_i];
      stream = stream.pipe(step());
    }
    if (dest) {
      stream = stream.pipe(gulp.dest(dest));
    }
    return stream;
  };

  exports.task = function() {
    var args, callback, deps, dest, name, pipes, src, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    _ref = parseArguments(args), name = _ref.name, deps = _ref.deps, callback = _ref.callback, src = _ref.src, pipes = _ref.pipes, dest = _ref.dest;
    return gulp.task(name, deps, callback || function() {
      return pipe(src(), pipes, dest);
    });
  };

  serving = void 0;

  shouldServe = function(file) {
    if (serving != null) {
      return subdir(serving.dir, file.path);
    }
  };

  livereload = function(file) {
    serving.instance.changeFile(file.path, {
      injectFileTypes: ['css', 'png', 'jpg', 'jpeg', 'svg', 'gif', 'webp']
    });
    return true;
  };

  exports.watch = function() {
    var args, callback, deps, dest, name, pipes, src, srcs, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    _ref = parseArguments(args), name = _ref.name, deps = _ref.deps, callback = _ref.callback, src = _ref.src, srcs = _ref.srcs, pipes = _ref.pipes, dest = _ref.dest;
    if (callback) {
      reportWrongUseOfWatch(name);
    }
    return gulp.task(name, deps, function() {
      var stream;
      once(function() {
        return gulp.watch(srcs, [name]);
      })();
      stream = src().pipe(cache(name));
      return pipe(stream, pipes, dest).pipe(filter(shouldServe)).pipe(notify('Compiled <%= file.relative %>')).pipe(filter(livereload));
    });
  };

  exports.serve = function(baseDir) {
    if (baseDir == null) {
      baseDir = './';
    }
    return serving = {
      dir: baseDir,
      instance: browserSync.init([], {
        server: {
          baseDir: baseDir
        },
        notify: false
      })
    };
  };

}).call(this);
